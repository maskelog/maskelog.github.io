<!doctype html>
<html lang="ko">
  <head>
    <title>객체 지향 프로그래밍 // maskelog blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.116.1">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="jihun han" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="객체 지향 프로그래밍"/>
<meta name="twitter:description" content="객체 지향 프로그래밍(Object-Oriented Programming, OOP) 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다. 대규모 프로젝트에서 프로그래밍 유지보수에 용이한 방식이다.
객체지향 프로그래밍의 주요 특징 추상화 (Abstraction):
정의: 복잡한 실세계의 개체를 프로그래밍에서 필요한 핵심 특징만을 간추려 표현하는 것. 예시: &lsquo;자동차&rsquo;라는 개체를 프로그래밍에 모델링할 때, 브랜드, 색상, 속도 등의 핵심 특징만을 표현하고, 제조 공정이나 재료 등의 세부 정보는 무시하는 것. 상속 (Inheritance):
정의: 기존의 클래스에서 정의된 속성과 메서드를 새로운 클래스에 그대로 전달받아 사용하는 것."/>

    <meta property="og:title" content="객체 지향 프로그래밍" />
<meta property="og:description" content="객체 지향 프로그래밍(Object-Oriented Programming, OOP) 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다. 대규모 프로젝트에서 프로그래밍 유지보수에 용이한 방식이다.
객체지향 프로그래밍의 주요 특징 추상화 (Abstraction):
정의: 복잡한 실세계의 개체를 프로그래밍에서 필요한 핵심 특징만을 간추려 표현하는 것. 예시: &lsquo;자동차&rsquo;라는 개체를 프로그래밍에 모델링할 때, 브랜드, 색상, 속도 등의 핵심 특징만을 표현하고, 제조 공정이나 재료 등의 세부 정보는 무시하는 것. 상속 (Inheritance):
정의: 기존의 클래스에서 정의된 속성과 메서드를 새로운 클래스에 그대로 전달받아 사용하는 것." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maskelog.github.io/posts/object-oriented-programming/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-24T21:54:25+09:00" />
<meta property="article:modified_time" content="2023-09-24T21:54:25+09:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://maskelog.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="jihun han" /></a>
      <span class="app-header-title">maskelog blog</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>프론트엔드 주니어 개발자</p>
      <div class="app-header-social">
        
          <a href="https://github.com/maskelog" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/brainhackerz" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>my twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">객체 지향 프로그래밍</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 24, 2023
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://maskelog.github.io/tags/javascript/">JavaScript</a>
              <a class="tag" href="https://maskelog.github.io/tags/oop/">OOP</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="객체-지향-프로그래밍object-oriented-programming-oop">객체 지향 프로그래밍(Object-Oriented Programming, OOP)</h3>
<p>프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다. 대규모 프로젝트에서 프로그래밍 유지보수에 용이한 방식이다.</p>
<h3 id="객체지향-프로그래밍의-주요-특징">객체지향 프로그래밍의 주요 특징</h3>
<ol>
<li>
<p><strong>추상화 (Abstraction)</strong>:</p>
<ul>
<li><strong>정의</strong>: 복잡한 실세계의 개체를 프로그래밍에서 필요한 핵심 특징만을 간추려 표현하는 것.</li>
<li><strong>예시</strong>: &lsquo;자동차&rsquo;라는 개체를 프로그래밍에 모델링할 때, 브랜드, 색상, 속도 등의 핵심 특징만을 표현하고, 제조 공정이나 재료 등의 세부 정보는 무시하는 것.</li>
</ul>
</li>
<li>
<p><strong>상속 (Inheritance)</strong>:</p>
<ul>
<li><strong>정의</strong>: 기존의 클래스에서 정의된 속성과 메서드를 새로운 클래스에 그대로 전달받아 사용하는 것.</li>
<li><strong>예시</strong>: &lsquo;동물&rsquo; 클래스의 기본 특징(예: 움직이다, 먹다)을 &lsquo;사자&rsquo; 또는 &lsquo;기린&rsquo;과 같은 하위 클래스가 상속받아 사용하는 것.</li>
</ul>
</li>
<li>
<p><strong>다형성 (Polymorphism)</strong>:</p>
<ul>
<li><strong>정의</strong>: 같은 이름의 메서드나 함수가 다른 동작을 수행하는 것.</li>
<li><strong>예시</strong>: &lsquo;동물&rsquo; 클래스에 &lsquo;울다&rsquo;라는 메서드가 있을 때, &lsquo;개&rsquo;는 &ldquo;멍멍&rdquo;, &lsquo;고양이&rsquo;는 &ldquo;야옹&quot;이라는 결과를 반환하는 것.</li>
</ul>
</li>
<li>
<p><strong>캡슐화 (Encapsulation)</strong>:</p>
<ul>
<li><strong>정의</strong>: 객체의 상태(속성)와 행동(메서드)을 하나로 묶고, 외부에서의 직접적인 접근을 제한하여 보호하는 것.</li>
<li><strong>예시</strong>: &lsquo;은행 계좌&rsquo; 객체에서 잔액 정보를 private로 설정하여 외부에서 직접 접근이 불가능하게 하되, 입금, 출금 등의 메서드를 통해서만 해당 정보를 조작할 수 있게 하는 것.</li>
</ul>
</li>
</ol>
<h3 id="절차지향-프로그래밍과-객체지향-프로그래밍-차이">절차지향 프로그래밍과 객체지향 프로그래밍 차이</h3>
<hr>
<table>
<thead>
<tr>
<th>구분</th>
<th>절차지향 프로그래밍</th>
<th>객체지향 프로그래밍</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>구조</strong></td>
<td>함수 중심</td>
<td>객체 중심</td>
</tr>
<tr>
<td><strong>데이터 사용</strong></td>
<td>전역 변수 활용</td>
<td>캡슐화된 데이터 사용</td>
</tr>
<tr>
<td><strong>재사용성</strong></td>
<td>함수 재사용</td>
<td>상속을 통한 재사용</td>
</tr>
<tr>
<td><strong>확장성</strong></td>
<td>전체 코드 변경 가능성 있음</td>
<td>객체 독립성에 따른 유연성</td>
</tr>
<tr>
<td><strong>유지보수</strong></td>
<td>대규모 프로젝트에 어려움</td>
<td>설계에 따른 용이성</td>
</tr>
<tr>
<td><strong>설계 방식</strong></td>
<td>큰 문제를 작은 부분으로 분해</td>
<td>실세계의 개체와 관계 모델링</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="객체지향-프로그래밍-방법">객체지향 프로그래밍 방법</h3>
<h4 id="프로토타입을-사용하여-객체의-공통-속성과-메서드를-정의하는-예제">프로토타입을 사용하여 객체의 공통 속성과 메서드를 정의하는 예제</h4>
<pre tabindex="0"><code>const PersonPrototype = {
  name: &#34;&#34;,
  age: 0,

  sayHi() {
    return `안녕, 나는 ${this.name}이야.`;
  },
};

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

Person.prototype = PersonPrototype;

const john = new Person(&#34;Hun&#34;, 20);

console.log(john.name); // &#34;Hun&#34;
console.log(john.age); // 20
console.log(john.sayHi()); // &#34;안녕, 나는 Hun이야.&#34;
</code></pre><p>위 코드에서 PersonPrototype 객체는 사람의 공통 속성과 메서드를 정의합니다. name과 age 속성과 sayHi() 메서드가 있습니다.</p>
<p>Person 클래스는 PersonPrototype 객체를 프로토타입으로 상속받습니다. 따라서 Person 클래스의 인스턴스에는 PersonPrototype 객체의 속성과 메서드가 자동으로 포함됩니다.</p>
<p>john 객체는 Person 클래스의 인스턴스입니다. 따라서 john 객체에는 name과 age 속성과 sayHi() 메서드가 있습니다.</p>
<h4 id="프로토타입을-사용하여-객체를-상속을-구현하는-예제">프로토타입을 사용하여 객체를 상속을 구현하는 예제</h4>
<pre tabindex="0"><code>const AnimalPrototype = {
  name: &#34;&#34;,
  speak() {
    return `${this.name} 소리를 냅니다.`;
  },
};

class Animal {
  constructor(name) {
    this.name = name;
  }
}

Animal.prototype = AnimalPrototype;

const DogPrototype = Object.create(AnimalPrototype);

DogPrototype.speak = function() {
    return `멍멍 소리를 냅니다.`;
  };

class Dog extends Animal {
}

const dog = new Dog(&#34;강아지&#34;);

console.log(dog.speak()); // &#34;멍멍 소리를 냅니다.&#34;
</code></pre><p>위 코드에서 AnimalPrototype 객체는 동물의 공통 속성과 메서드를 정의합니다. name 속성과 speak() 메서드가 있습니다.</p>
<p>Animal 클래스는 AnimalPrototype 객체를 프로토타입으로 상속받습니다. 따라서 Animal 클래스의 인스턴스에는 AnimalPrototype 객체의 속성과 메서드가 자동으로 포함됩니다.</p>
<p>DogPrototype 객체는 AnimalPrototype 객체를 상속받습니다. speak() 메서드가 재정의되어 있습니다.</p>
<p>Dog 클래스는 Animal 클래스를 상속받습니다. 따라서 Dog 클래스의 인스턴스에는 AnimalPrototype 객체와 DogPrototype 객체의 속성과 메서드가 모두 포함됩니다.</p>
<p>dog 객체는 Dog 클래스의 인스턴스입니다. 따라서 dog 객체의 speak() 메서드는 DogPrototype 객체의 재정의된 메서드를 실행합니다.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
